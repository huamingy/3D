<!DOCTYPE html>
<html lang="CH">
  <head>
    <title>灵山大楼</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="../css/main.css" />
  </head>

  <body>
    <script type="module">
      import * as THREE from '../../build/three.module.js'

      import Stats from '../jsm/libs/stats.module.js'

      import { OrbitControls } from '../jsm/controls/OrbitControls.js'
      // import { FBXLoader } from './jsm/loaders/FBXLoader.js';
      import { GLTFLoader } from '../jsm/loaders/GLTFLoader.js'
      import { CSS3DRenderer } from '../jsm/renderers/CSS3DRenderer.js'
      import { GUI } from '../jsm/libs/dat.gui.module.js'

      let camera, scene, renderer, stats

      const clock = new THREE.Clock()

      let mixer
      const params = {
        enableFoor1: true,
        enableFoor2: true,
        enableDevie: true,
      }
      const fun = function () {
        this.message = function () {}
        this.jifang = function () {
          window.location.href = './Map.html'
        }
        this.back = function () {
          window.location.href = './Map.html'
        }
      }

      var funn = new fun()
      // function simulate( now ) {
      // 	if(params.enableFoor1){
      // 		console.log("enableFoor1");
      // 	}
      // }

      init()
      initControls()
      animate()

      function init() {
        const container = document.createElement('div')
        document.body.appendChild(container)

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        )
        camera.position.set(0, 10, 10) //镜头XYZ位置
        // camera.up.set(1, 0, 1);//镜头面向朝向
        // camera.position.z = 2;
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x000000)
        //scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );
        // const ambient = new THREE.AmbientLight(0x444444);//环境光源
        // scene.add(ambient);
        // 点光源（PointLight）表示的是从一个点朝各个方向发射出光线的一种光照效果
        const point = new THREE.PointLight(0xffffff)
        // point.position.set(100, 3000, 100); //点光源位置
        // 通过add方法插入场景中，不插入的话，渲染的时候不会获取光源的信息进行光照计算
        scene.add(point) //点光源添加到场景中
        // const point1 = new THREE.PointLight(0xffffff);//点光源
        // point1.position.set(100, 300, 600); //点光源位置
        // scene.add(point1); //点光源添加到场景中

        // 半球光（HemisphereLight）的颜色是从天空到地面两个颜色之间的渐变，与物体材质的颜色作叠加后得到最终的颜色效果
        const hemiLight = new THREE.HemisphereLight(0xf8f8ff, 0x444444)
        // hemiLight.position.set( 0, 8000, 0 );
        scene.add(hemiLight)

        // 方向光，常常用来表现太阳光照的效果
        const dirLight = new THREE.DirectionalLight(0xf8f8ff)
        // dirLight.position.set( 300, 500, 100 );
        dirLight.castShadow = true
        dirLight.shadow.camera.top = 180
        dirLight.shadow.camera.bottom = -100
        dirLight.shadow.camera.left = -120
        dirLight.shadow.camera.right = 120
        scene.add(dirLight)

        scene.add(new THREE.CameraHelper(dirLight.shadow.camera))

        // ground
        const mesh = new THREE.Mesh(
          new THREE.PlaneGeometry(2000, 2000),
          new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
        )
        mesh.rotation.x = -Math.PI / 2
        mesh.receiveShadow = true
        //scene.add( mesh );

        // 坐标格辅助对象. 坐标格实际上是2维线数组.
        const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000)
        grid.material.opacity = 0.2
        grid.material.transparent = true
        //scene.add( grid );

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMap.enabled = true
        renderer.autoClear = false
        renderer.gammaInput = true
        renderer.gammaOutput = true //inear转gamma
        container.appendChild(renderer.domElement)

        window.addEventListener('resize', onWindowResize)
        //界面
        const gui = new GUI()

        /* gui.add( params, 'enableFoor1' ).name( '内部' ).onChange(function(){
      					// Plane作为元素创建数组，Plane的方向法向量、位置根据需要随意定义
      var PlaneArr = [
      //创建一个垂直x轴的平面，方向沿着x轴负方向，沿着x轴正方向平移20,
      // new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20),
      // 垂直y轴的平面
      new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.384*1),
      // 垂直z轴的平面
      // new THREE.Plane(new THREE.Vector3(0, 0, -1), -2000)
      ];
      // 设置渲染器的剪裁平面属性
      renderer.clippingPlanes = PlaneArr;

      }); */
        /* gui.add( params, 'enableFoor2' ).name( '外部' ).onChange(function(){
      // Plane作为元素创建数组，Plane的方向法向量、位置根据需要随意定义
      var PlaneArr = [
      //创建一个垂直x轴的平面，方向沿着x轴负方向，沿着x轴正方向平移20,
      // new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20),
      // 垂直y轴的平面
      new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.384*2),
      // 垂直z轴的平面
      // new THREE.Plane(new THREE.Vector3(0, 0, -1), -2000)
      ];
      // 设置渲染器的剪裁平面属性
      renderer.clippingPlanes = PlaneArr;
         }); */

        gui.add(funn, 'message').name('灵山大楼 ')

        gui.add(funn, 'back').name('返回')
        // .name('返回')
        // .onChange(function name() {
        //   window.location.href = './Map.html'
        // })
        // 默认值设置
        var dropdown = { 楼层: '全景' }
        //选项
        var states = [
          '1层',
          '2层',
          '3层',
          '4层',
          '5层',
          '6层',
          '7层',
          '8层',
          '全景',
        ]
        // 添加
        var clipCtrl = gui.add(dropdown, '楼层').options(states)
        // 设置点击事件
        clipCtrl.onChange((floor) => {
          var PlaneArr
          if (floor == '1层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 1 - 0.002),
            ]
          } else if (floor == '2层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 2 - 0.002),
            ]
          } else if (floor == '3层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 3 - 0.002),
            ]
          } else if (floor == '4层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 4 - 0.002),
            ]
          } else if (floor == '5层') {
            ;(window.location.href = './LingShanBuilding_9F.html'),
              (PlaneArr = [
                new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 5 - 0.002),
              ])
          } else if (floor == '6层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 6 - 0.002),
            ]
          } else if (floor == '7层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 7 - 0.002),
            ]
          } else if (floor == '8层') {
            PlaneArr = [
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.385 * 8 - 0.002),
            ]
          } else {
            PlaneArr = [new THREE.Plane(new THREE.Vector3(0, -1, 0), 10)]
          }
          renderer.clippingPlanes = PlaneArr
        })

        //

        // Plane作为元素创建数组，Plane的方向法向量、位置根据需要随意定义
        // var PlaneArr = [
        // //创建一个垂直x轴的平面，方向沿着x轴负方向，沿着x轴正方向平移20,
        // // new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20),
        // // 垂直y轴的平面
        // new THREE.Plane(new THREE.Vector3(0, -1, 0), 500),
        // // 垂直z轴的平面
        // // new THREE.Plane(new THREE.Vector3(0, 0, -1), -2000)
        // ];
        // // 设置渲染器的剪裁平面属性
        // renderer.clippingPlanes = PlaneArr;

        // 通过PlaneHelper辅助可视化显示剪裁平面Plane
        // var helper = new THREE.PlaneHelper(PlaneArr[0], 300, 0xffff00);
        // scene.add(helper);
        // var helper2 = new THREE.PlaneHelper(PlaneArr[1], 300, 0xff00ff);
        // scene.add(helper2);

        // model
        const loader = new GLTFLoader()
        loader.load(
          '../models/LingShanBuilding/LingShanBuilding.gltf',
          function (object) {
            mixer = new THREE.AnimationMixer(object)

            // const action = mixer.clipAction( object.animations[ 0 ] );
            // action.play();

            object.scene.traverse(function (child) {
              if (child.isMesh) {
                child.castShadow = true
                child.receiveShadow = true
              }
            })
            object.scene.position.y = +0.2
            scene.add(object.scene)
          }
        )
        /* const loader = new GLTFLoader();
      loader.load( 'models/LingShanBuilding/LingShanBuilding.gltf', function ( gltf ) {
      	console.log('控制台查看加载gltf文件返回的对象结构',gltf)
      	  console.log('gltf对象场景属性',gltf.scene)
      	  console.log('gltf对象相机属性',gltf.cameras)

      	scene.add( gltf.scene );

      }, undefined, function ( error ) {

      	console.error( error );

      } ); */

        // stats
        stats = new Stats()
        container.appendChild(stats.dom)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)
      }
      //const controls = new OrbitControls( camera, renderer.domElement );
      function initControls() {
        const controls = new OrbitControls(camera, renderer.domElement)

        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true
        //是否自动旋转
        controls.autoRotate = true
        //设置相机距离原点的最远距离
        controls.minDistance = 15
        //设置相机距离原点的最远距离
        controls.maxDistance = 100
        //是否开启右键拖拽
        controls.enablePan = true

        // 上下旋转范围
        controls.minPolarAngle = 0

        controls.maxPolarAngle = Math.PI / 2
      }

      function render() {
        renderer.render(scene, camera)
        controls.update()
      }

      function animate() {
        requestAnimationFrame(animate)

        const delta = clock.getDelta()

        if (mixer) mixer.update(delta)

        renderer.render(scene, camera)

        stats.update()
      }
    </script>
  </body>
</html>
