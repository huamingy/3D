<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>激光楼(贴图)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <script type="module">
      import * as THREE from './build/three.module.js'
      import { FBXLoader } from './jsm/loaders/FBXLoader.js'
      import { GUI } from './jsm/libs/dat.gui.module.js'
      import { OrbitControls } from './jsm/controls/OrbitControls.js'
      import {
        CSS3DRenderer,
        CSS3DObject,
        CSS3DSprite,
      } from './jsm/renderers/CSS3DRenderer.js'
      import { RoamUtil } from './js/Util.js'
      var params = {
        enableFoor1: false,
        enableFoor2: false,
        enableDevie: true,
        LengQueLouPipe: false,
        LengQueLouEquipmemt: false,
        JiGuangLouPipe: false,
        JiGuangLouEquipment: false,
        JiGuangLouPipefly: false,
        fly: false,
        run: false,
        out: false,
      }

      var granaryArr = [] //被点击的模型对象数组
      var device1 = null //冷却楼设备
      var device3 = null //空调设备容器
      var nextPos = new THREE.Vector3() //射线点击建筑对应XOZ平面坐标
      var dir = new THREE.Vector3() //飞行漫游方向，起始点构成的方向 默认值0，0，0
      var choosemesh = null //射线拾取的模型
      var pipe = 0 //全局管道选择的条件
      var obj = document.getElementById('label')
      var th = document.getElementById('TH')
      var flyBool = false //作为视角移动的条件
      var flyPipe = false //作为管道飞行的条件
      var label = null //html 弹出标签容器
      var pos = null
      var numb = null

      /**
       * 创建场景对象Scene
       */
      var scene = new THREE.Scene()
      // var geometry1 = new THREE.BoxGeometry(1000, 1000, 1000)
      // var material1 = new THREE.MeshLambertMaterial({
      //   color: 0x0000ff,
      //   side: THREE.DoubleSide,
      // }) //材质对象Material
      // var mesh1 = new THREE.Mesh(geometry1, material1) //网格模型对象Mesh
      // scene.add(mesh1) //网格模型添加到场景中
      // mesh1.position.set(0, 5000, 20000)
      /**
       * 光源设置*/
      var point = new THREE.PointLight(0x999999) //点光源
      point.castShadow = true
      point.position.set(0, 5000, 30000) //点光源位置
      scene.add(point) //点光源添加到场景中

      const point1 = new THREE.PointLight(0x999999) //点光源
      point1.castShadow = true
      point1.position.set(0, 5000, -30000) //点光源位置
      scene.add(point1) //点光源添加到场景中

      const point2 = new THREE.PointLight(0x999999, 0.5) //点光源
      point2.castShadow = true
      point2.position.set(-550000, 100000, 0) //点光源位置
      scene.add(point2) //点光源添加到场景中

      var ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
      scene.add(ambientLight)
      var spotLight = new THREE.SpotLight(0xffffff, 0.5)
      spotLight.castShadow = true
      spotLight.position.set(-30000, 8000, -25000)
      scene.add(spotLight)

      const light = new THREE.DirectionalLight(0xffffff, 0.8) // 平行光，颜色为白色，强度为1
      light.position.set(-30000, 10000, -25000) // 设置灯源位置
      light.castShadow = true // 允许生成阴影
      scene.add(light) // 添加到场景中

      var LightHelper3 = new THREE.DirectionalLightHelper(light, 5000, 0xff0000)
      scene.add(LightHelper3)

      var LightHelper = new THREE.PointLightHelper(point, 5000, 0xff0000)
      scene.add(LightHelper)

      var LightHelper1 = new THREE.PointLightHelper(point1, 5000, 0xff0000)
      scene.add(LightHelper1)

      var LightHelper2 = new THREE.PointLightHelper(point2, 5000, 0xff0000)
      scene.add(LightHelper2)
      /**
       * 相机设置
       */
      var width = window.innerWidth //窗口宽度
      var height = window.innerHeight //窗口高度
      var k = width / height //窗口宽高比

      //创建相机对象
      var camera = new THREE.PerspectiveCamera(60, k, 100, 500000)
      camera.position.set(-31000, 41000, 0) //设置相机位置
      // camera.lookAt(scene.position) //设置相机方向(指向的场景对象)

      //创建CSS2D渲染器
      var labelRender = new CSS3DRenderer()
      labelRender.setSize(width, height)
      labelRender.domElement.style.position = 'absolute'
      // 避免renderer.domElement影响HTMl标签定位，设置top为0px
      labelRender.domElement.style.top = '0px'
      labelRender.domElement.style.left = '0px'
      //设置.pointerEvents=none，以免模型标签HTML元素遮挡鼠标选择场景模型
      labelRender.domElement.style.pointerEvents = 'none'
      document.body.appendChild(labelRender.domElement)

      //创建渲染器对象
      var renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      })
      renderer.setSize(width, height) //设置渲染区域尺寸
      renderer.setClearColor(0x000000, 1) //设置背景颜色
      renderer.shadowMap.enabled = true
      renderer.toneMapping = THREE.ACESFilmicToneMapping
      renderer.toneMappingExposure = 1
      renderer.outputEncoding = THREE.sRGBEncoding
      renderer.localClippingEnabled = true //剖切特定的模型
      document.body.appendChild(renderer.domElement) //body元素中插入canvas对象

      var mixer = null
      var loader = new FBXLoader()
      loader.load('./models/JiGuangLou/JiGungLou.fbx', function (object) {
        console.log('打印对象', object)
        scene.add(object)
        object.traverse(function (child) {
          if (child.isMesh) {
            child.castShadow = true
            child.receiveShadow = true
          }
        })
      })
      loader.load(
        './models/JiGuangLou/JiGungLou_Aircondition.FBX',
        function (object) {
          console.log('打印对象', object)
          scene.add(object)

          mixer = new THREE.AnimationMixer(object)

          var AnimationAction = mixer.clipAction(object.animations[0])
          // console.log('object.animations: ', object.animations)
          AnimationAction.play()
        }
      )
      //二号通风管道视线曲线
      var curve2 = new THREE.CurvePath()
      var arr2 = [
        new THREE.Vector3(3136, 320, 2673), //入口
        new THREE.Vector3(2700, 320, 2673),
        new THREE.Vector3(2700, 320, 2030),
        new THREE.Vector3(2915, 320, 2033), //三入
        new THREE.Vector3(2915, 40, 2033), //三入
        new THREE.Vector3(2915, 40, 2000), //三入
      ]
      // // 从曲线上获得501个顶点，数量根据需要自己设置
      var points2 = curve2.getSpacedPoints(3000)

      //三号通风管道视线曲线
      // 三维样条曲线CatmullRomCurve3创建一个曲线路径
      var curve3 = new THREE.CurvePath()
      var arr3 = [
        new THREE.Vector3(3100, 320, -575), //入口
        new THREE.Vector3(2670, 320, -575),
        new THREE.Vector3(2670, 320, 1200),
        new THREE.Vector3(2980, 300, 1195),
        new THREE.Vector3(2980, 30, 1195),
        new THREE.Vector3(2980, 30, 1170),
      ]

      // // 从曲线上获得501个顶点，数量根据需要自己设置
      var points3 = curve3.getSpacedPoints(5000)

      // 三维样条曲线CatmullRomCurve3创建一个曲线路径
      var curve4 = new THREE.CurvePath()
      var arr4 = [
        new THREE.Vector3(3120, 320, -504),
        new THREE.Vector3(2750, 320, -504),
        new THREE.Vector3(2750, 320, 418),
        new THREE.Vector3(3000, 320, 418),
        new THREE.Vector3(3000, 38, 400),
        new THREE.Vector3(3000, 38, 340),
      ]

      // 从曲线上获得501个顶点，数量根据需要自己设置
      var points4 = curve4.getSpacedPoints(2500)

      var curve5 = new THREE.CurvePath()
      var arr5 = [
        new THREE.Vector3(3118, 320, -1041), //入口
        new THREE.Vector3(2700, 320, -1041),
        new THREE.Vector3(2700, 320, -2008),
        new THREE.Vector3(2950, 320, -2008), //三入
        new THREE.Vector3(2950, 50, -2008), //三入
        new THREE.Vector3(2950, 50, -2064), //三入
      ]

      // 从曲线上获得501个顶点，数量根据需要自己设置
      var points5 = curve5.getSpacedPoints(2500)

      var curve7 = new THREE.CurvePath()
      var arr7 = [
        new THREE.Vector3(3123, 320, -3450), //入口
        new THREE.Vector3(2800, 320, -3450), //一中
        new THREE.Vector3(2800, 320, -2780), //入口
        new THREE.Vector3(3000, 320, -2780), //入口
        new THREE.Vector3(3000, 38, -2810), //
        new THREE.Vector3(3000, 38, -2879), //出口
      ]

      // 从曲线上获得501个顶点，数量根据需要自己设置
      var points7 = curve7.getSpacedPoints(2500)

      var curve8 = new THREE.CurvePath()

      var arr8 = [
        new THREE.Vector3(3123, 320, -3492), //入口
        new THREE.Vector3(2746, 320, -3492),
        new THREE.Vector3(2746, 320, -2850),
        new THREE.Vector3(2550, 320, -2850), //三入
        new THREE.Vector3(2550, 30, -2850), //三入
        new THREE.Vector3(2550, 30, -2966), //三入
      ]
      // 从曲线上获得501个顶点，数量根据需要自己设置
      var points8 = curve8.getSpacedPoints(2500)
      var arr9 = [
        new THREE.Vector3(-31000, 41000, 0), //入口
        new THREE.Vector3(-3000, 6500, 0),
      ]
      var R = 90 //圆弧半径
      var curve = new THREE.CurvePath()
      //直线轨迹坐标
      var arr = [
        new THREE.Vector3(-2700, 180, 600), //入口
        new THREE.Vector3(-2300, 180, 500), //
        new THREE.Vector3(-2300, 180, -2200), //
        new THREE.Vector3(2300, 180, -2200), //
        new THREE.Vector3(2300, 180, 3750), //
        new THREE.Vector3(-2300, 180, 3750), //
        new THREE.Vector3(-2300, 180, 500), //
        new THREE.Vector3(-2700, 180, 400), //入口
      ]
      points = curve.getSpacedPoints(10000)
      var geometry = new THREE.BufferGeometry() //声明一个几何体对象Geometry
      // geometry.setFromPoints(points)
      // 材质对象
      var material = new THREE.LineBasicMaterial({
        color: 0xffff00,
        opacity: 0.5,
      })
      //线条模型对象
      var line = new THREE.Line(geometry, material)
      scene.add(line)

      var points = []

      function createcurve(arr, num) {
        var curve = new THREE.CurvePath()
        // 从曲线上获得501个顶点，数量根据需要自己设置
        // var points = curve.getPoints(6000);
        for (var i = 0; i < arr.length - 1; i++) {
          if (i == 0) {
            var dir = arr[0].clone().sub(arr[1])
            dir.normalize()
            var p2 = arr[1].clone()
            p2.add(dir.clone().multiplyScalar(R))
            var line = new THREE.LineCurve3(arr[0], p2)
            curve.curves.push(line)
          } else {
            // 计算三个点构成的两条线的方向
            var dir1 = arr[i - 1].clone().sub(arr[i])
            dir1.normalize()
            var dir2 = arr[i + 1].clone().sub(arr[i])
            dir2.normalize()
            var p12_ = arr[i].clone()
            p12_.add(dir1.clone().multiplyScalar(R))
            var p1 = arr[i].clone().add(dir1.clone().multiplyScalar(R))
            var p2 = arr[i].clone()
            var p3 = arr[i].clone().add(dir2.clone().multiplyScalar(R))
            var beziercurve = new THREE.QuadraticBezierCurve3(p1, p2, p3)
            var line1 = arr[i].clone()
            line1.add(dir2.clone().multiplyScalar(R))
            var line2 = arr[i + 1].clone()
            if (i < arr.length - 2) {
              //最后一段不用减掉半径尺寸
              line2.add(dir2.clone().multiplyScalar(-R))
            }
            var line = new THREE.LineCurve3(line1, line2)
            // 把转换曲线和直线插入曲线中
            curve.curves.push(beziercurve, line)
          }
        }
        points = curve.getSpacedPoints(num)
      }
      // var axesHelper = new THREE.AxesHelper(30000);
      //     axesHelper.position.y= -50
      //     scene.add(axesHelper);
      // var gridHelper = new THREE.GridHelper(100000, 100,0x222222,0xdddddd);
      //     gridHelper.position.y = -500
      //     scene.add(gridHelper);

      var gui = new GUI()
      var a = null
      var funt = {
        opcitay: function () {
          scene.getObjectByName('ChuFengKou_Pipe').traverse(function (mesh) {
            mesh.isMesh && (mesh.material.visible = a)
          })
          scene.getObjectByName('OutLet').traverse(function (mesh) {
            mesh.isMesh && (mesh.material.visible = a)
          })
          a = a == false ? true : false
        },
      }
      gui.add(funt, 'opcitay').name('通风管道透明')

      gui
        .add(params, 'enableFoor1')
        .name('内部')
        .onChange((e) => {
          var Dev = scene.getObjectByName('JiGuangLou')
          if (e == true) {
            var PlaneArr = [
              //创建一个垂直x轴的平面，方向沿着x轴负方向，沿着x轴正方向平移20,
              // new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20),
              // 垂直y轴的平面
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 450),
              // 垂直z轴的平面
            ]
            // device1.material.clippingPlanes=PlaneArr;
            // 设置渲染器的剪裁平面属性
            Dev.traverse(function (obj) {
              if (obj.type == 'Mesh') {
                obj.material.clippingPlanes = PlaneArr
              }
            })

            if (
              params.JiGuangLouEquipment == true ||
              params.LengQueLouEquipmemt == true
            ) {
            } else {
              camera.position.set(-9000, 19500, 0) //设置相机位置
              // camera.lookAt(0, 0, 0)
              camera.lookAt(0, 0, 0)
              pos = scene.position
              numb = 8000
              dir.copy(pos.clone().sub(camera.position)).normalize()
              flyBool = true //允许飞行
            }
          } else {
            var PlaneArr = [
              //创建一个垂直x轴的平面，方向沿着x轴负方向，沿着x轴正方向平移20,
              // new THREE.Plane(new THREE.Vector3(-1, 0, 0), 20),
              // 垂直y轴的平面
              new THREE.Plane(new THREE.Vector3(0, -1, 0), 6000),
              // 垂直z轴的平面
              // new THREE.Plane(new THREE.Vector3(0, 0, -1), -2000)
            ]
            // 设置渲染器的剪裁平面属性

            Dev.traverse(function (obj) {
              if (obj.type == 'Mesh') {
                obj.material.clippingPlanes = PlaneArr
              }
            })
            flyBool = false
          }
        })

      gui
        .add(params, 'LengQueLouPipe')
        .name('冷却楼管道')
        .onChange((e) => {
          var device = scene.getObjectByName('LengQueLouPipe')

          if (e == true) {
            device.children.forEach(function (mesh) {
              var edges = new THREE.EdgesGeometry(mesh.geometry, 1)
              var edgesMaterial = new THREE.LineBasicMaterial({
                color: 0x31deef,
              })
              var line = new THREE.LineSegments(edges, edgesMaterial)
              line.name = 'line'
              mesh.add(line)
            })
          } else {
            device.children.forEach(function (mesh) {
              var line = scene.getObjectByName('line')
              mesh.remove(line)
            })
          }
        })
      gui
        .add(params, 'LengQueLouEquipmemt')
        .name('冷却楼设备')
        .onChange((e) => {
          device1 = scene.getObjectByName('LengQueLouEquipmemt')
          if (e == true) {
            device1.children.forEach(function (mesh) {
              // 批量更改模型的颜色

              cteatetag(
                mesh,
                '冷却楼设备',
                '运行状态：',
                '正常',
                '周期:',
                '67h',
                '温度:',
                '28℃',
                '湿度:',
                '40%'
              )
            })
            pos = device1.position
            camera.lookAt(pos)
            numb = 1500
            dir.copy(pos.clone().sub(camera.position)).normalize()
            flyBool = true //允许飞行
          } else {
            device1.children.forEach(function (mesh) {
              deletetag()
            })
          }
        })

      // gui
      //   .add(params, 'JiGuangLouPipe')
      //   .name('空调管道')
      //   .onChange((e) => {
      //     var device2 = scene.getObjectByName('JiGuangLouPipe')
      //     if (e == true) {
      //       device2.traverse(function (mesh) {
      //         var edges = new THREE.EdgesGeometry(mesh.geometry, 1)
      //         var edgesMaterial = new THREE.LineBasicMaterial({
      //           color: 0x31deef,
      //         })
      //         var line = new THREE.LineSegments(edges, edgesMaterial)
      //         line.name = 'line'
      //         mesh.add(line)
      //       })
      //     } else {
      //       device2.children.forEach(function (mesh) {
      //         var line = scene.getObjectByName('line')
      //         mesh.remove(line)
      //       })
      //     }
      //   })
      gui
        .add(params, 'JiGuangLouEquipment')
        .name('空调设备')
        .onChange((e) => {
          device3 = scene.getObjectByName('OutLet')

          if (e == true) {
            device3.children.forEach(function (mesh) {
              cteatetag(
                mesh,
                mesh.name,
                '运行状态：',
                '正常',
                '周期:',
                '67h',
                '温度:',
                '28℃',
                '湿度:',
                '40%'
              )

              console.log('mesh.position: ', mesh.position)
            })

            camera.position.set(800, 2100, -382) //设置相机位置
            camera.lookAt(device3.position)
          } else {
            device3.children.forEach(function (mesh) {
              deletetag()
            })
          }
        })
      gui
        .add(params, 'enableFoor2')
        .name('冷却水循环水泵')
        .onChange((e) => {
          var device = scene.getObjectByName('Object263')
        })

      var TrendsGui = new GUI()

      TrendsGui.domElement.style =
        'position:absolute;right:0px;top:600px;background-color: aqua;'
      TrendsGui.add(params, 'fly')
        .name('浏览设备')
        .onChange((e) => {
          if (e == true) {
            createcurve(arr, 15000)
            flyPipe = true
          } else {
            flyPipe = false
          }
        })
      TrendsGui.add(params, 'fly')
        .name('通风管道')
        .onChange((e) => {
          if (e == true) {
            createcurve(arr2, 2000)
            flyPipe = true
            pipe = 2
          } else {
            flyPipe = false
          }
        })

      TrendsGui.add(params, 'run')
        .name('暂停/继续')
        .onChange((e) => {
          if (num == 0) {
            flyPipe = false
          } else {
            if (flyPipe == true || flyBool == true) {
              flyPipe = false
              flyBool = false
            } else {
              flyPipe = true
            }
          }
        })

      TrendsGui.add(params, 'out')
        .name('退出')
        .onChange((e) => {
          num = 0

          camera.position.set(10000, 5000, 0) //设置相机位置
          camera.lookAt(0, 0, 0)
        })
      function cteatetag(
        mesh,
        tagtext,
        text,
        run,
        time,
        timevalue,
        temperature,
        temperaturevalue,
        humidity,
        humidityvalue
      ) {
        //创建一个canvas画布绘制模型的信息，作为模型标签精灵的颜色贴图
        var canvas = document.createElement('canvas')
        //精灵模型会随着场景缩放，注意画布宽高尺寸不能太小
        canvas.width = 300
        canvas.height = 100
        var c = canvas.getContext('2d')
        // 矩形区域填充背景，半透明
        c.fillStyle = '#42A4F6'
        c.fillRect(0, 0, 300, 300)
        c.beginPath()
        c.beginPath()
        c.translate(32, 32)
        c.font = 'bold 35px 宋体'
        c.textBaseline = 'middle'
        c.fillStyle = '#224058'
        c.fillText(tagtext, 50, 2.5)
        // c.fillStyle = '#5599FF'
        // c.fillRect(20, 40, 200, 100)
        // c.font = 'bold 25px 宋体'
        // c.fillStyle = '#ffffff'
        // c.fillText(text, 40, 75)
        // c.fillStyle = '#f8f544'
        // c.fillText(run, 155, 75)
        // c.fillStyle = '#ffffff'
        // c.fillText(time, 40, 110)
        // c.fillStyle = '#8ADA84'
        // c.fillText(timevalue, 110, 110)
        // c.fillStyle = '#fac73c'
        // c.fillText(temperature, 40, 175)
        // c.fillStyle = '#ffffff'
        // c.fillText(temperaturevalue, 110, 175)
        // c.fillStyle = '#62D844'
        // c.fillText(humidity, 40, 210)
        // c.fillStyle = '#ffffff'
        // c.fillText(humidityvalue, 110, 210)

        // canvas画布对象作为CanvasTexture的参数重建一个纹理对象
        label = new CSS3DSprite(canvas)
        label.name = 'label'
        label.position.copy(mesh.getWorldPosition())

        label.position.y += 300
        label.position.x += -100
        scene.add(label)
      }

      function deletetag() {
        label = scene.getObjectByName('label')
        if (label) label.parent.remove(label)
      }

      var num = 0
      // 创建一个时钟对象Clock
      var clock = new THREE.Clock()
      function render() {
        RoamUtil()
        renderer.render(scene, camera)
        requestAnimationFrame(render)
        labelRender.render(scene, camera)

        if (mixer !== null) {
          mixer.update(clock.getDelta()) //更新混合器相关的时间
        }
        if (flyBool) {
          var dis = camera.position.clone().sub(pos).length()

          // console.log('dis', dis)
          if (dis > numb) {
            // 接近nextPos位置，相机停止飞行
            //每次渲染相机沿着视线移动距离递增(xyz每个分量乘以4)
            camera.position.add(dir.clone().multiplyScalar(80))

            //  console.log("render -> nextPos.position", nextPos.position)
          } else {
            flyBool = false //停止飞行飞行
          }
        } else if (flyPipe) {
          fly(points)
        }
      }

      render()
      function fly(points) {
        if (num < points.length - 100) {
          var i = Math.floor(num)
          // 相机位置设置在当前点位置
          camera.position.set(points[i].x, points[i].y, points[i].z)
          // 设置相机观察点为当前点的下一个点，两点可以构成一个视线方向
          // 你可以简单理解为：要始终保持视线为曲线的切线方向
          camera.lookAt(
            new THREE.Vector3(
              points[i + 1].x,
              points[i].y - 0.01,
              points[i + 1].z
            )
          )
          num += 2 //调节速度
        } else {
          flyPipe = false
          num = 0
        }
      }

      var controls = new OrbitControls(camera, renderer.domElement)

      // onresize 事件会在窗口被调整大小时发生
      window.onresize = function () {
        // 重置渲染器输出画布canvas尺寸
        renderer.setSize(window.innerWidth, window.innerHeight)
        // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比
        camera.aspect = window.innerWidth / window.innerHeight
        // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix
        // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)
        // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵
        camera.updateProjectionMatrix()
      }
    </script>
  </body>
</html>
